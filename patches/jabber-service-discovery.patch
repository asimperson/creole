Jabber Service Discovery by nops < http://developer.pidgin.im/ticket/556 >
============================================================
Index: libpurple/disco.c
===================================================================
--- /dev/null
+++ libpurple/disco.c
@@ -0,0 +1,160 @@
+/**
+ * @file disco.c Service Discovery API
+ * @ingroup core
+ */
+
+/* purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "debug.h"
+
+#include "disco.h"
+
+static PurpleDiscoUiOps *ops = NULL;
+
+PurpleDiscoList *purple_disco_list_new(PurpleAccount *account)
+{
+	PurpleDiscoList *list;
+
+	g_return_val_if_fail(account != NULL, NULL);
+
+	list = g_new0(PurpleDiscoList, 1);
+	list->account = account;
+	list->ref = 1;
+
+/*	if (ops && ops->create)
+		ops->create(list); */
+
+	return list;
+}
+
+void purple_disco_list_ref(PurpleDiscoList *list)
+{
+	g_return_if_fail(list != NULL);
+
+	list->ref++;
+	purple_debug_misc("disco", "reffing list, ref count now %d\n", list->ref);
+}
+
+static void purple_disco_list_service_destroy(PurpleDiscoList *list, PurpleDiscoService *r)
+{
+	g_free(r->name);
+	g_free(r->description);
+	g_free(r);
+}
+
+static void purple_disco_list_destroy(PurpleDiscoList *list)
+{
+	GList *l;
+
+	purple_debug_misc("disco", "destroying list %p\n", list);
+
+/*	if (ops && ops->destroy)
+		ops->destroy(list); */
+
+	for (l = list->services; l; l = l->next) {
+		PurpleDiscoService *s = l->data;
+		purple_disco_list_service_destroy(list, s);
+	}
+	g_list_free(list->services);
+
+	g_free(list);
+}
+
+void purple_disco_list_unref(PurpleDiscoList *list)
+{
+	g_return_if_fail(list != NULL);
+	g_return_if_fail(list->ref > 0);
+
+	list->ref--;
+
+	purple_debug_misc("disco", "unreffing list, ref count now %d\n", list->ref);
+	if (list->ref == 0)
+		purple_disco_list_destroy(list);
+}
+
+void purple_disco_list_service_add(PurpleDiscoList *list, PurpleDiscoService *service)
+{
+	g_return_if_fail(list != NULL);
+	g_return_if_fail(service != NULL);
+
+	list->services = g_list_append(list->services, service);
+
+	if (ops && ops->add_service)
+		ops->add_service(list, service);
+}
+
+PurpleDiscoService *purple_disco_list_service_new(PurpleDiscoServiceCategory category, const gchar *name,
+		PurpleDiscoServiceType type, const gchar *description, int flags)
+{
+	PurpleDiscoService *s;
+
+	g_return_val_if_fail(name != NULL, NULL);
+
+	s = g_new0(PurpleDiscoService, 1);
+	s->category = category;
+	s->name = g_strdup(name);
+	s->type = type;
+	s->description = g_strdup(description);
+	s->flags = flags;
+
+	return s;
+}
+
+void purple_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list)
+{
+	PurplePlugin *prpl = NULL;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+
+	g_return_val_if_fail(gc != NULL, NULL);
+
+	prpl = purple_connection_get_prpl(gc);
+
+	if (prpl != NULL)
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+	if (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_get_list))
+		return prpl_info->disco_get_list(gc, list);
+
+	return NULL;
+}
+
+int purple_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service)
+{
+	PurplePlugin *prpl = NULL;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+
+	g_return_val_if_fail(gc != NULL, NULL);
+
+	prpl = purple_connection_get_prpl(gc);
+
+	if (prpl != NULL)
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+	if (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_service_register))
+		return prpl_info->disco_service_register(gc, service);
+}
+
+void purple_disco_set_ui_ops(PurpleDiscoUiOps *ui_ops)
+{
+	ops = ui_ops;
+}
Index: libpurple/disco.h
===================================================================
--- /dev/null
+++ libpurple/disco.h
@@ -0,0 +1,165 @@
+/**
+ * @file disco.h Service Discovery API
+ * @ingroup core
+ */
+
+/* purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#ifndef _PURPLE_DISCO_H_
+#define _PURPLE_DISCO_H_
+
+
+typedef struct _PurpleDiscoList PurpleDiscoList;
+typedef struct _PurpleDiscoService PurpleDiscoService;
+typedef struct _PurpleDiscoUiOps PurpleDiscoUiOps;
+
+#include "account.h"
+
+/**
+ * Represents a list of services for a given connection on a given protocol.
+ */
+struct _PurpleDiscoList {
+	PurpleAccount *account; /**< The account this list belongs to. */
+	GList *services; /**< The list of services. */
+	gpointer *ui_data; /**< UI private data. */
+	gpointer proto_data; /** Prpl private data. */
+	guint ref; /**< The reference count. */
+};
+
+/**
+ * The categories of services.
+ */
+typedef enum
+{
+	PURPLE_DISCO_SERVICE_CAT_NONE,		/**< Other category */
+	PURPLE_DISCO_SERVICE_CAT_GATEWAY,
+	PURPLE_DISCO_SERVICE_CAT_DIRECTORY,
+	PURPLE_DISCO_SERVICE_CAT_MUC
+} PurpleDiscoServiceCategory;
+
+/**
+ * The types of services.
+ */
+typedef enum
+{
+	PURPLE_DISCO_SERVICE_TYPE_NONE,
+	PURPLE_DISCO_SERVICE_TYPE_XMPP,
+	PURPLE_DISCO_SERVICE_TYPE_ICQ,
+	PURPLE_DISCO_SERVICE_TYPE_MAIL
+} PurpleDiscoServiceType;
+
+/**
+ * The flags of services.
+ */
+#define PURPLE_DISCO_FLAG_NONE		0
+#define PURPLE_DISCO_FLAG_ADD		1 << 0
+#define PURPLE_DISCO_FLAG_BROWSE	1 << 1
+#define PURPLE_DISCO_FLAG_REGISTER	1 << 2
+
+/**
+ * Represents a list of services for a given connection on a given protocol.
+ */
+struct _PurpleDiscoService {
+	PurpleDiscoServiceCategory category; /**< The category of service. */
+	gchar *name; /**< The name of the service. */
+	PurpleDiscoServiceType type; /**< The type of service. */
+	int flags;
+	gchar *description; /**< The name of the service. */
+};
+
+struct _PurpleDiscoUiOps {
+	void (*dialog_show_with_account)(PurpleAccount* account); /**< Force the ui to pop up a dialog */
+	void (*add_service)(PurpleDiscoList *list, PurpleDiscoService *service); /**< Add service to dialog */
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Returns a newly created service discovery object.
+ *
+ * It has an initial reference count of 1.
+ *
+ * @param account The account that's listing rooms.
+ * @return The new service discovery list handle.
+ */
+PurpleDiscoList *purple_disco_list_new(PurpleAccount *account);
+
+/**
+ * Increases the reference count on the service discovery list.
+ *
+ * @param list The object to ref.
+ */
+void purple_disco_list_ref(PurpleDiscoList *list);
+
+/**
+ * Decreases the reference count on the service discovery list.
+ *
+ * The room list will be destroyed when this reaches 0.
+ *
+ * @param list The room list object to unref and possibly
+ *             destroy.
+ */
+void purple_disco_list_unref(PurpleDiscoList *list);
+
+/**
+ * Returns a PurpleDiscoList structure from the prpl, and
+ * instructs the prpl to start fetching the list.
+ *
+ * @param gc The PurpleConnection to have get a list.
+ *
+ * @return A PurpleDiscoList* or @c NULL if the protocol
+ *         doesn't support that.
+ */
+void purple_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list);
+
+/**
+ * Create new service object
+ */
+PurpleDiscoService *purple_disco_list_service_new(PurpleDiscoServiceCategory category, const gchar *name,
+		PurpleDiscoServiceType type, const gchar *description, int flags);
+
+/**
+ * Add service to list
+ */
+void purple_disco_list_service_add(PurpleDiscoList *list, PurpleDiscoService *service);
+
+/**
+ * Sets the UI operations structure to be used in all purple service discovery.
+ *
+ * @param ops The UI operations structure.
+ */
+void purple_disco_set_ui_ops(PurpleDiscoUiOps *ui_ops);
+
+/**
+ * Register service
+ * @param gc Connection
+ * @param service The service that will be registered
+ */
+int purple_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PURPLE_DISCO_H_ */
Index: carrier/gtkdisco.c
===================================================================
--- /dev/null
+++ carrier/gtkdisco.c
@@ -0,0 +1,392 @@
+/**
+ * @file gtkdisco.c GTK+ Service Discovery UI
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "pidgin.h"
+#include "gtkutils.h"
+#include "debug.h"
+#include "disco.h"
+
+#include "gtkdisco.h"
+
+typedef struct _PidginDiscoList {
+
+	GtkTreeStore *model;
+	GtkWidget *tree;
+
+} PidginDiscoList;
+
+typedef struct _PidginDiscoDialog {
+	GtkWidget *window;
+	GtkWidget *account_widget;
+	
+	GtkWidget *sw;
+	GtkTreeStore *model;
+	GtkWidget *tree;
+
+	GtkWidget *list_button;
+	GtkWidget *register_button;
+	GtkWidget *add_button;
+	GtkWidget *close_button;
+
+	PurpleAccount *account;
+	PurpleDiscoList *discolist;
+} PidginDiscoDialog;
+
+struct _menu_cb_info {
+	PurpleDiscoList *list;
+	PurpleDiscoService *service;
+};
+
+enum {
+	NAME_COLUMN = 0,
+	DESCRIPTION_COLUMN,
+	SERVICE_COLUMN,
+	NUM_OF_COLUMNS
+};
+
+static void dialog_select_account_cb(GObject *w, PurpleAccount *account,
+				     PidginDiscoDialog *dialog)
+{
+	dialog->account = account;
+}
+
+static void register_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+	struct _menu_cb_info *info = g_object_get_data(G_OBJECT(button), "disco-info");
+	PurpleConnection *gc = purple_account_get_connection(info->list->account);
+
+	purple_disco_service_register(gc, info->service);
+}
+
+static void list_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+	PurpleConnection *gc;
+	PidginDiscoList *ui_data;
+
+	gc = purple_account_get_connection(dialog->account);
+	if (!gc)
+		return;
+
+	gtk_tree_store_clear(dialog->model);
+
+	if (dialog->discolist != NULL)
+		purple_disco_list_unref(dialog->discolist);
+	
+	dialog->discolist = purple_disco_list_new(dialog->account);
+	ui_data = g_new0(PidginDiscoList, 1);
+	ui_data->tree = dialog->tree;
+	ui_data->model = dialog->model;
+	dialog->discolist->ui_data = (void*) ui_data;
+
+	purple_disco_get_list(gc, dialog->discolist);
+}
+
+static void add_room_to_blist_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+	struct _menu_cb_info *info = g_object_get_data(G_OBJECT(button), "disco-info");
+
+	if (info)
+		purple_blist_request_add_buddy(info->list->account, info->service->name, NULL, NULL);
+}
+
+static void
+selection_changed_cb(GtkTreeSelection *selection, PidginDiscoDialog *dialog) 
+{
+	PidginDiscoList *dl = (PidginDiscoList *) dialog->discolist->ui_data;
+	PurpleDiscoService *service;
+	GtkTreeIter iter;
+	GValue val;
+	static struct _menu_cb_info *info;
+
+	if (gtk_tree_selection_get_selected(selection, NULL, &iter)) {
+		val.g_type = 0;
+		gtk_tree_model_get_value(GTK_TREE_MODEL(dl-> model), &iter, SERVICE_COLUMN, &val);
+		service = g_value_get_pointer(&val);
+		if (!service) {
+			gtk_widget_set_sensitive(dialog->add_button, FALSE);
+			gtk_widget_set_sensitive(dialog->register_button, FALSE);
+			return;
+		}
+
+		info = g_new0(struct _menu_cb_info, 1);
+		info->list = dialog->discolist;
+		info->service = service;
+
+		g_object_set_data(G_OBJECT(dialog->add_button), "disco-info", info);
+		g_object_set_data(G_OBJECT(dialog->register_button), "disco-info", info);
+
+		gtk_widget_set_sensitive(dialog->add_button, service->flags & PURPLE_DISCO_FLAG_ADD);
+		gtk_widget_set_sensitive(dialog->register_button, service->flags & PURPLE_DISCO_FLAG_REGISTER);
+	} else {
+		gtk_widget_set_sensitive(dialog->add_button, FALSE);
+		gtk_widget_set_sensitive(dialog->register_button, FALSE);
+	}
+}
+
+static gint
+delete_win_cb(GtkWidget *w, GdkEventAny *e, gpointer d)
+{
+	PidginDiscoDialog *dialog = d;
+
+	if (dialog->discolist) {
+		/*PidginDiscoList *dl = (PidginDiscoList) dialog->discolist->ui_data;
+
+		if (dl)
+			dl->dialog = NULL; */
+		purple_disco_list_unref(dialog->discolist);
+	}
+
+	g_free(dialog);
+
+	return FALSE;
+}
+
+static void close_button_cb(GtkButton *button, PidginDiscoDialog *dialog)
+{
+	GtkWidget *window = dialog->window;
+
+	delete_win_cb(NULL, NULL, dialog);
+	gtk_widget_destroy(window);
+}
+
+static gboolean account_filter_func(PurpleAccount *account)
+{
+	PurpleConnection *conn = purple_account_get_connection(account);
+	PurplePluginProtocolInfo *prpl_info = NULL;
+
+	if (conn)
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(conn->prpl);
+
+	return (prpl_info && PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl_info, disco_get_list));
+}
+
+gboolean
+pidgin_disco_is_showable()
+{
+	GList *c;
+	PurpleConnection *gc;
+
+	for (c = purple_connections_get_all(); c != NULL; c = c->next) {
+		gc = c->data;
+
+		if (account_filter_func(purple_connection_get_account(gc)))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+static void pidgin_disco_create_tree(PidginDiscoDialog *dialog)
+{
+	GtkCellRenderer *renderer;
+	GtkTreeViewColumn *column;
+	GtkTreeSelection *selection;
+
+	dialog->model = gtk_tree_store_new(NUM_OF_COLUMNS,
+			G_TYPE_STRING,		/* NAME_COLUMN */
+			G_TYPE_STRING,		/* DESCRIPTION_COLUMN */
+			G_TYPE_POINTER		/* SERVICE_COLUMN */
+	);
+
+	dialog->tree = gtk_tree_view_new_with_model(GTK_TREE_MODEL(dialog->model));
+	gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(dialog->tree), TRUE);
+
+	selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(dialog->tree));
+	g_signal_connect(G_OBJECT(selection), "changed",
+					 G_CALLBACK(selection_changed_cb), dialog);
+
+	g_object_unref(dialog->model);
+
+	gtk_container_add(GTK_CONTAINER(dialog->sw), dialog->tree);
+	gtk_widget_show(dialog->tree);
+
+	renderer = gtk_cell_renderer_text_new();
+	column = gtk_tree_view_column_new_with_attributes(_("Name"), renderer,
+				"text", NAME_COLUMN, NULL);
+	gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(column),
+	                                GTK_TREE_VIEW_COLUMN_GROW_ONLY);
+	gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+	gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(column), NAME_COLUMN);
+	gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+	gtk_tree_view_append_column(GTK_TREE_VIEW(dialog->tree), column);
+
+	column = gtk_tree_view_column_new_with_attributes(_("Description"), renderer,
+				"text", DESCRIPTION_COLUMN, NULL);
+	gtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(column),
+	                                GTK_TREE_VIEW_COLUMN_GROW_ONLY);
+	gtk_tree_view_column_set_resizable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+	gtk_tree_view_column_set_sort_column_id(GTK_TREE_VIEW_COLUMN(column), DESCRIPTION_COLUMN);
+	gtk_tree_view_column_set_reorderable(GTK_TREE_VIEW_COLUMN(column), TRUE);
+	gtk_tree_view_append_column(GTK_TREE_VIEW(dialog->tree), column);
+}
+
+static PidginDiscoDialog*
+pidgin_disco_dialog_new_with_account(PurpleAccount *account)
+{
+	PidginDiscoDialog *dialog;
+	GtkWidget *window, *vbox, *vbox2, *bbox;
+
+	dialog = g_new0(PidginDiscoDialog, 1);
+	dialog->account = account;
+	dialog->discolist = (void*) g_new0(PidginDiscoList, 1);
+
+	/* Create the window. */
+	dialog->window = window = pidgin_create_dialog(_("Service Discovery"), PIDGIN_HIG_BORDER, "service discovery", TRUE);
+
+	g_signal_connect(G_OBJECT(window), "delete_event",
+					 G_CALLBACK(delete_win_cb), dialog);
+
+	/* Create the parent vbox for everything. */
+	vbox = pidgin_dialog_get_vbox_with_properties(GTK_DIALOG(window), FALSE, PIDGIN_HIG_BORDER);
+
+	vbox2 = gtk_vbox_new(FALSE, PIDGIN_HIG_BORDER);
+	gtk_container_add(GTK_CONTAINER(vbox), vbox2);
+	gtk_widget_show(vbox2);
+
+	/* accounts dropdown list */
+	dialog->account_widget = pidgin_account_option_menu_new(dialog->account, FALSE,
+	                         G_CALLBACK(dialog_select_account_cb), account_filter_func, dialog);
+	if (!dialog->account) /* this is normally null, and we normally don't care what the first selected item is */
+		dialog->account = pidgin_account_option_menu_get_selected(dialog->account_widget);
+	pidgin_add_widget_to_vbox(GTK_BOX(vbox2), _("_Account:"), NULL, dialog->account_widget, TRUE, NULL);
+
+	/* scrolled window */
+	dialog->sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(dialog->sw),
+	                                    GTK_SHADOW_IN);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(dialog->sw),
+	                               GTK_POLICY_AUTOMATIC,
+	                               GTK_POLICY_AUTOMATIC);
+	gtk_box_pack_start(GTK_BOX(vbox2), dialog->sw, TRUE, TRUE, 0);
+	gtk_widget_set_size_request(dialog->sw, -1, 250);
+	gtk_widget_show(dialog->sw);
+
+	/* button box */
+	bbox = pidgin_dialog_get_action_area(GTK_DIALOG(window));
+	gtk_box_set_spacing(GTK_BOX(bbox), PIDGIN_HIG_BOX_SPACE);
+	gtk_button_box_set_layout(GTK_BUTTON_BOX(bbox), GTK_BUTTONBOX_END);
+
+	/* list button */
+	dialog->list_button = pidgin_pixbuf_button_from_stock(_("_Get List"), GTK_STOCK_REFRESH,
+	                                                    PIDGIN_BUTTON_HORIZONTAL);
+	gtk_box_pack_start(GTK_BOX(bbox), dialog->list_button, FALSE, FALSE, 0);
+	g_signal_connect(G_OBJECT(dialog->list_button), "clicked",
+	                 G_CALLBACK(list_button_cb), dialog);
+	gtk_widget_show(dialog->list_button);
+
+	/* register button */
+	dialog->register_button = pidgin_dialog_add_button(GTK_DIALOG(dialog->window), _("Register"),
+	                 G_CALLBACK(register_button_cb), dialog);
+	gtk_widget_set_sensitive(dialog->register_button, FALSE);
+
+	/* add button */
+	dialog->add_button = pidgin_pixbuf_button_from_stock(_("_Add"), GTK_STOCK_ADD,
+	                                                    PIDGIN_BUTTON_HORIZONTAL);
+	gtk_box_pack_start(GTK_BOX(bbox), dialog->add_button, FALSE, FALSE, 0);
+	g_signal_connect(G_OBJECT(dialog->add_button), "clicked",
+	                 G_CALLBACK(add_room_to_blist_cb), dialog);
+	gtk_widget_set_sensitive(dialog->add_button, FALSE);
+	gtk_widget_show(dialog->add_button);
+
+	/* join button */
+	/*dialog->join_button = pidgin_pixbuf_button_from_stock(_("_Join"), PIDGIN_STOCK_CHAT,
+	                                                    PIDGIN_BUTTON_HORIZONTAL);
+	gtk_box_pack_start(GTK_BOX(bbox), dialog->join_button, FALSE, FALSE, 0);
+	g_signal_connect(G_OBJECT(dialog->join_button), "clicked",
+					 G_CALLBACK(join_button_cb), dialog);
+	gtk_widget_set_sensitive(dialog->join_button, FALSE);
+	gtk_widget_show(dialog->join_button);*/
+
+	/* close button */
+	dialog->close_button = pidgin_dialog_add_button(GTK_DIALOG(window), GTK_STOCK_CLOSE,
+					 G_CALLBACK(close_button_cb), dialog);
+
+	pidgin_disco_create_tree(dialog);
+
+	/* show the dialog window and return the dialog */
+	gtk_widget_show(dialog->window);
+
+	return dialog;
+}
+
+void
+pidgin_disco_dialog_show(void)
+{
+	pidgin_disco_dialog_new_with_account(NULL);
+}
+
+void
+pidgin_disco_dialog_show_with_account(PurpleAccount* account)
+{
+	PidginDiscoDialog *dialog = pidgin_disco_dialog_new_with_account(account);
+
+	if (!dialog)
+		return;
+
+	list_button_cb(GTK_BUTTON(dialog->list_button), dialog);
+}
+
+static void pidgin_disco_add_service(PurpleDiscoList *list, PurpleDiscoService *service)
+{
+	PidginDiscoList *dl = (PidginDiscoList *) list->ui_data;
+	GtkTreeIter iter;
+
+	purple_debug_info("disco", "add_service");
+	/*if (dl->dialog)
+		dl->dialog->pg_needs_pulse = TRUE;*/
+
+	gtk_tree_store_append(dl->model, &iter, NULL);
+
+	/*path = gtk_tree_model_get_path(GTK_TREE_MODEL(rl->model), &iter);
+
+	if (room->type & PURPLE_ROOMLIST_ROOMTYPE_CATEGORY) {
+		rr = gtk_tree_row_reference_new(GTK_TREE_MODEL(rl->model), path);
+		g_hash_table_insert(rl->cats, room, rr);
+	}
+
+	gtk_tree_path_free(path); */
+
+	gtk_tree_store_set(dl->model, &iter, NAME_COLUMN, service->name, -1);
+	gtk_tree_store_set(dl->model, &iter, DESCRIPTION_COLUMN, service->description, -1);
+	gtk_tree_store_set(dl->model, &iter, SERVICE_COLUMN, service, -1);
+
+/*	for (j = NUM_OF_COLUMNS, l = room->fields, k = list->fields; l && k; j++, l = l->next, k = k->next) {
+		PurpleRoomlistField *f = k->data;
+		if (f->hidden)
+			continue;
+		gtk_tree_store_set(rl->model, &iter, j, l->data, -1);
+	}*/
+}
+
+static PurpleDiscoUiOps ops = {
+	pidgin_disco_dialog_show_with_account,
+	pidgin_disco_add_service
+};
+
+void pidgin_disco_init() {
+	purple_disco_set_ui_ops(&ops);
+}
Index: carrier/gtkdisco.h
===================================================================
--- /dev/null
+++ carrier/gtkdisco.h
@@ -0,0 +1,56 @@
+/**
+ * @file gtkdisco.c GTK+ Service Discovery UI
+ * @ingroup pidgin
+ */
+
+/* pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#ifndef _GTK_DISCO_H_
+#define _GTK_DISCO_H_
+
+
+/**
+ * Initializes the service discovery subsystem.
+ */
+void pidgin_disco_init(void);
+
+/**
+ * Determines if showing the service discovery dialog is a valid action.
+ *
+ * @return TRUE if there are accounts online that support service
+ *         discovery.  Otherwise return FALSE.
+ */
+gboolean pidgin_disco_is_showable(void);
+
+/**
+ * Shows a new service discovery dialog.
+ */
+void pidgin_disco_dialog_show(void);
+
+/**
+ * Shows a new service discovery dialog and fetches the list for the specified account.
+ *
+ * @param account The account to use.
+ */
+void pidgin_disco_dialog_show_with_account(PurpleAccount *account);
+
+#endif /* _GTK_DISCO_H_ */
Index: libpurple/Makefile.am
===================================================================
--- libpurple/Makefile.am.orig
+++ libpurple/Makefile.am
@@ -65,6 +65,7 @@ purple_coresources = \
 	prpl.c \
 	request.c \
 	roomlist.c \
+	disco.c \
 	savedstatuses.c \
 	server.c \
 	signals.c \
@@ -118,6 +119,7 @@ purple_coreheaders = \
 	prpl.h \
 	request.h \
 	roomlist.h \
+	disco.h \
 	savedstatuses.h \
 	server.h \
 	signals.h \
@@ -155,7 +157,7 @@ dbus_sources  = dbus-server.c dbus-usefu
 dbus_headers  = dbus-bindings.h dbus-purple.h dbus-server.h dbus-useful.h dbus-define-api.h dbus-types.h
 
 dbus_exported = dbus-useful.h dbus-define-api.h account.h blist.h buddyicon.h \
-                connection.h conversation.h core.h ft.h log.h notify.h prefs.h roomlist.h \
+                connection.h conversation.h core.h ft.h log.h notify.h prefs.h roomlist.h disco.h \
                 savedstatuses.h smiley.h status.h server.h util.h xmlnode.h prpl.h
 
 purple_build_coreheaders = $(addprefix $(srcdir)/, $(purple_coreheaders)) \
Index: libpurple/protocols/jabber/disco.c
===================================================================
--- libpurple/protocols/jabber/disco.c.orig
+++ libpurple/protocols/jabber/disco.c
@@ -22,6 +22,8 @@
 #include "internal.h"
 #include "prefs.h"
 #include "debug.h"
+#include "request.h"
+#include "notify.h"
 
 #include "buddy.h"
 #include "google.h"
@@ -32,7 +34,8 @@
 #include "roster.h"
 #include "pep.h"
 #include "adhoccommands.h"
-
+#include "xdata.h"
+#include "libpurple/disco.h"
 
 struct _jabber_disco_info_cb_data {
 	gpointer data;
@@ -270,6 +273,8 @@ void jabber_disco_info_parse(JabberStrea
 					capabilities |= JABBER_CAP_IQ_REGISTER;
 				else if(!strcmp(var, "http://www.xmpp.org/extensions/xep-0199.html#ns"))
 					capabilities |= JABBER_CAP_PING;
+				else if(!strcmp(var, "http://jabber.org/protocol/disco#items"))
+					capabilities |= JABBER_CAP_ITEMS;
 				else if(!strcmp(var, "http://jabber.org/protocol/commands")) {
 					capabilities |= JABBER_CAP_ADHOC;
 				}
@@ -309,7 +314,8 @@ void jabber_disco_info_parse(JabberStrea
 	}
 }
 
-void jabber_disco_items_parse(JabberStream *js, xmlnode *packet) {
+void jabber_disco_items_parse(JabberStream *js, xmlnode *packet)
+{
 	const char *from = xmlnode_get_attrib(packet, "from");
 	const char *type = xmlnode_get_attrib(packet, "type");
 
@@ -549,4 +555,300 @@ void jabber_disco_info_do(JabberStream *
 	jabber_iq_send(iq);
 }
 
+static void
+jabber_disco_service_info_cb(JabberStream *js, xmlnode *packet, PurpleDiscoList *list)
+{
+	xmlnode *query, *ident, *child;
+	const char *from = xmlnode_get_attrib(packet, "from");
+	const char *result = xmlnode_get_attrib(packet, "type");
+	const char *acat, *atype, *adesc;
+	PurpleDiscoService *s;
+	PurpleDiscoServiceCategory cat = PURPLE_DISCO_SERVICE_CAT_NONE;
+	PurpleDiscoServiceType type = PURPLE_DISCO_SERVICE_TYPE_NONE;
+	int flags = PURPLE_DISCO_FLAG_ADD;
+
+	if (!from || !result || (strcmp(result, "result"))
+			|| (!(query = xmlnode_get_child(packet, "query")))
+			|| (!(ident = xmlnode_get_child(query, "identity")))) {
+		purple_disco_list_unref(list);
+		return;
+	}
+
+	acat = xmlnode_get_attrib(ident, "category");
+	atype = xmlnode_get_attrib(ident, "type");
+	adesc = xmlnode_get_attrib(ident, "name");
+
+	if (!strcmp(acat, "gateway"))
+		cat = PURPLE_DISCO_SERVICE_CAT_GATEWAY;
+	else if (!strcmp(acat, "directory"))
+		cat = PURPLE_DISCO_SERVICE_CAT_DIRECTORY;
+	else if (!strcmp(acat, "conference"))
+		cat = PURPLE_DISCO_SERVICE_CAT_MUC;
+	
+	if (!strcmp(atype, "XMPP"))
+		type = PURPLE_DISCO_SERVICE_TYPE_XMPP;
+	else if (!strcmp(atype, "icq"))
+		type = PURPLE_DISCO_SERVICE_TYPE_ICQ;
+	else if (!strcmp(atype, "mrim"))
+		type = PURPLE_DISCO_SERVICE_TYPE_MAIL;
+	
+	for (child = xmlnode_get_child(query, "feature"); child;
+			child = xmlnode_get_next_twin(child)) {
+		const char *var;
+
+		if (!(var = xmlnode_get_attrib(child, "var")))
+			continue;
+		
+		if (!strcmp(var, "jabber:iq:register"))
+			flags |= PURPLE_DISCO_FLAG_REGISTER;
+		
+		if (!strcmp(var, "http://jabber.org/protocol/disco#items"))
+			flags |= PURPLE_DISCO_FLAG_BROWSE;
+	}
+	purple_debug_info("disco", "service %s, category %s (%d), type %s (%d), description %s, flags %04x\n",
+			from,
+			acat, cat,
+			atype, type,
+			adesc, flags);
+
+	s = purple_disco_list_service_new(cat, from, type, adesc, flags);
+	purple_disco_list_service_add(list, s);
+	purple_disco_list_unref(list);
+}
+
+static void
+jabber_disco_server_items_cb(JabberStream *js, xmlnode *packet, PurpleDiscoList *list)
+{
+	xmlnode *query, *child;
+	const char *from = xmlnode_get_attrib(packet, "from");
+	const char *type = xmlnode_get_attrib(packet, "type");
+
+	if (!from || !type)
+		return;
+
+	if (strcmp(type, "result"))
+		return;
+
+	query = xmlnode_get_child(packet, "query");
+
+	for(child = xmlnode_get_child(query, "item"); child;
+			child = xmlnode_get_next_twin(child)) {
+		JabberIq *iq;
+		const char *jid;
+
+		if(!(jid = xmlnode_get_attrib(child, "jid")))
+			continue;
+
+		purple_disco_list_ref(list);
+		iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#info");
+		xmlnode_set_attrib(iq->node, "to", jid);
+		jabber_iq_set_callback(iq, jabber_disco_service_info_cb, (gpointer) list);
+
+		jabber_iq_send(iq);
+	}
+
+	purple_disco_list_unref(list);
+}
+
+static void
+jabber_disco_host_info_cb(JabberStream *js, const char *who, JabberCapabilities caps, PurpleDiscoList *list)
+{
+	JabberIq *iq;
+
+	if (caps & JABBER_CAP_ITEMS) {
+		iq = jabber_iq_new_query(js, JABBER_IQ_GET, "http://jabber.org/protocol/disco#items");
+		xmlnode_set_attrib(iq->node, "to", who);
+		jabber_iq_set_callback(iq, jabber_disco_server_items_cb, (gpointer) list);
+		
+		jabber_iq_send(iq);
+	} else {
+		purple_notify_error(NULL, _("Error"), _("Server don't support service discovery"), NULL); 
+		purple_disco_list_unref(list);
+	}
+}
+
+static void
+jabber_disco_host_cb(PurpleDiscoList *list, PurpleRequestFields *fields)
+{
+	const char *server_name;
+
+	server_name = purple_request_fields_get_string(fields, "server");
+	purple_debug_misc("jabber", "Service discovery for %s\n", server_name);
+
+	jabber_disco_info_do(list->proto_data, server_name, jabber_disco_host_info_cb, list);
+}
+
+void
+jabber_disco_get_list(PurpleConnection *gc, PurpleDiscoList *list)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *g;
+	PurpleRequestField *f;
+	JabberStream *js;
+
+	js = gc->proto_data;
+	list->proto_data = js;
+
+	fields = purple_request_fields_new();
+	g = purple_request_field_group_new(NULL);
+	f = purple_request_field_string_new("server", _("Server"), js->user->domain, FALSE);
+
+	purple_request_field_group_add_field(g, f);
+	purple_request_fields_add_group(fields, g);
+	
+	purple_disco_list_ref(list);
+	
+	purple_request_fields(gc,
+		_("Server name request"),
+		_("Enter server name"),
+		NULL,
+		fields,
+		_("OK"), G_CALLBACK(jabber_disco_host_cb),
+		_("Cancel"), NULL,
+		purple_connection_get_account(gc), NULL, NULL, list);
+}
+
+static void
+jabber_disco_service_register_inform_cb(JabberStream *js, xmlnode *packet, PurpleDiscoService *service) {
+	const char *type = xmlnode_get_attrib(packet, "type");
+	xmlnode *query = xmlnode_get_child(packet, "query");
+	xmlnode *registered = query ? xmlnode_get_child(query, "registered") : NULL;
+	char buf[100];
+
+	if (!strcmp(type, "result") && (!query || (query && registered)) ) {
+		g_snprintf(buf, sizeof(buf), _("Registration \"%s\" service successful"), service->name);
+		purple_notify_info(js->gc, _("Registration"), buf, NULL);
+	} else {
+		g_snprintf(buf, sizeof(buf), _("Registration \"%s\" service error"), service->name);
+		purple_notify_error(js->gc, _("Registration"), buf, NULL);
+	}
+}
+
+static void
+jabber_disco_service_register_cb(GList *params, PurpleRequestFields *fields)
+{
+	const PurpleRequestFieldGroup *g;
+	GList *field;
+	const PurpleDiscoService *service; 
+	const PurpleConnection *gc;
+	JabberStream *js;
+	JabberIq *iq;
+	xmlnode *query;
+	
+	service = params->data;
+	gc = g_list_next(params)->data;
+	js = gc->proto_data;
+	g = g_list_next(g_list_next(params))->data;
+	purple_debug_misc("jabber", "Register service %s\n", service->name);
+	
+	iq = jabber_iq_new_query(js, JABBER_IQ_GET, "jabber:iq:register");
+	xmlnode_set_attrib(iq->node, "to", service->name);
+	jabber_iq_set_callback(iq, jabber_disco_service_register_inform_cb, (gpointer) service);
+
+	query = xmlnode_get_child(iq->node, "query");
+	
+	for (field = purple_request_field_group_get_fields(g);
+			field != NULL; field = g_list_next(field)) {
+		PurpleRequestField *f = field->data;
+		xmlnode *child = xmlnode_new_child(query, purple_request_field_get_id(f));
+		char* val = purple_request_field_string_get_value(f);
+
+		if (val)
+			xmlnode_insert_data(child, val, -1);
+	}
+	
+	jabber_iq_send(iq);
+}
+
+static void
+jabber_disco_service_register_x_data_cb(JabberStream *js, xmlnode *result, PurpleDiscoService *service)
+{
+	JabberIq *iq;
+	xmlnode *query;
+
+	purple_debug_misc("jabber", "Register service %s with xdata\n", service->name);
+	
+	iq = jabber_iq_new_query(js, JABBER_IQ_GET, "jabber:iq:register");
+	xmlnode_set_attrib(iq->node, "to", service->name);
+	jabber_iq_set_callback(iq, jabber_disco_service_register_inform_cb, (gpointer) service);
+	query = xmlnode_get_child(iq->node, "query");
+	xmlnode_insert_child(query, result);
+	jabber_iq_send(iq);
+}
+
+static void
+jabber_disco_service_register_fields_cb(JabberStream *js, xmlnode *packet, PurpleDiscoService *service)
+{
+	const char *from = xmlnode_get_attrib(packet, "from");
+	const char *type = xmlnode_get_attrib(packet, "type");
+	const xmlnode *query = xmlnode_get_child(packet, "query");
+	xmlnode *instructions, *child, *x;
+	char* instructions_text;
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *g;
+	PurpleRequestField *f;
+	GList *params;
+
+	if (!from || !type)
+		return;
+
+	if (strcmp(from, service->name))
+		return;
+
+	if (strcmp(type, "result"))
+		return;
+
+	if (x = xmlnode_get_child(query, "x")) {
+		jabber_x_data_request(js, x, jabber_disco_service_register_x_data_cb, service);
+		return;
+	}
+	
+	fields = purple_request_fields_new();
+	g = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, g);
+
+	for(child = query->child; child; child = child->next)
+		if (strcmp(child->name, "instructions")
+				&& strcmp(child->name, "key")
+				&& strcmp(child->name, "x")
+				&& strcmp(child->name, "registered")) {
+			char* data = xmlnode_get_data(child);
+
+			f = purple_request_field_string_new(child->name, child->name, data, FALSE);
+			purple_request_field_group_add_field(g, f);
+			g_free(data);
+		}
+
+	instructions = xmlnode_get_child(query, "instructions");
+	instructions_text = xmlnode_get_data(instructions);
+	
+	params = g_list_append(params, service);
+	params = g_list_append(params, js->gc);
+	params = g_list_append(params, g);
+
+	purple_request_fields(js->gc,
+		_("Registration"),
+		instructions_text,
+		NULL,
+		fields,
+		_("OK"), G_CALLBACK(jabber_disco_service_register_cb),
+		_("Cancel"), NULL,
+		purple_connection_get_account(js->gc), NULL, NULL, params);
+
+	g_free(instructions_text);
+}
+
+int
+jabber_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service)
+{
+	JabberStream *js = gc->proto_data;
+	JabberIq *iq;
+	
+	iq = jabber_iq_new_query(js, JABBER_IQ_GET, "jabber:iq:register");
+	xmlnode_set_attrib(iq->node, "to", service->name);
+	jabber_iq_set_callback(iq, jabber_disco_service_register_fields_cb, (gpointer) service);
+		
+	jabber_iq_send(iq);
 
+	return 0;
+}
Index: libpurple/protocols/jabber/disco.h
===================================================================
--- libpurple/protocols/jabber/disco.h.orig
+++ libpurple/protocols/jabber/disco.h
@@ -35,4 +35,8 @@ void jabber_disco_items_server(JabberStr
 void jabber_disco_info_do(JabberStream *js, const char *who,
 		JabberDiscoInfoCallback *callback, gpointer data);
 
+void jabber_disco_get_list(PurpleConnection *gc, PurpleDiscoList* list);
+
+int jabber_disco_service_register(PurpleConnection *gc, PurpleDiscoService *service);
+
 #endif /* _PURPLE_JABBER_DISCO_H_ */
Index: libpurple/protocols/jabber/jabber.h
===================================================================
--- libpurple/protocols/jabber/jabber.h.orig
+++ libpurple/protocols/jabber/jabber.h
@@ -43,6 +43,8 @@ typedef enum {
 	JABBER_CAP_PING			  = 1 << 11,
 	JABBER_CAP_ADHOC		  = 1 << 12,
 	
+	JABBER_CAP_ITEMS          = 1 << 13,
+
 	JABBER_CAP_RETRIEVED      = 1 << 31
 } JabberCapabilities;
 
Index: libpurple/protocols/jabber/libxmpp.c
===================================================================
--- libpurple/protocols/jabber/libxmpp.c.orig
+++ libpurple/protocols/jabber/libxmpp.c
@@ -34,6 +34,7 @@
 #include "iq.h"
 #include "jabber.h"
 #include "chat.h"
+#include "disco.h"
 #include "message.h"
 #include "roster.h"
 #include "si.h"
@@ -118,7 +119,10 @@ static PurplePluginProtocolInfo prpl_inf
 	jabber_attention_types,			/* attention_types */
 
 	sizeof(PurplePluginProtocolInfo),       /* struct_size */
-	NULL
+	NULL,
+	jabber_disco_get_list,			/* disco_get_list */
+	jabber_disco_service_register		/* disco_service_register */
+
 };
 
 static gboolean load_plugin(PurplePlugin *plugin)
Index: libpurple/prpl.h
===================================================================
--- libpurple/prpl.h.orig
+++ libpurple/prpl.h
@@ -69,6 +69,7 @@ typedef struct _PurpleBuddyIconSpec Purp
 #include "proxy.h"
 #include "plugin.h"
 #include "roomlist.h"
+#include "disco.h"
 #include "status.h"
 #include "whiteboard.h"
 
@@ -449,6 +450,16 @@ struct _PurplePluginProtocolInfo
 	 *         destroyed by the caller when it's no longer needed.
 	 */
 	GHashTable *(*get_account_text_table)(PurpleAccount *account);
+
+	/**
+	 * Service discovery prpl callbacks
+	 */
+	void (*disco_get_list)(PurpleConnection *gc, PurpleDiscoList *list);
+
+	/**
+	 * Register service
+	 */
+	int (*disco_service_register)(PurpleConnection *gc, PurpleDiscoService *service);
 };
 
 #define PURPLE_PROTOCOL_PLUGIN_HAS_FUNC(prpl, member) \
Index: libpurple/purple.h.in
===================================================================
--- libpurple/purple.h.in.orig
+++ libpurple/purple.h.in
@@ -79,6 +79,7 @@
 #include <prpl.h>
 #include <request.h>
 #include <roomlist.h>
+#include <disco.h>
 #include <savedstatuses.h>
 #include <server.h>
 #include <signals.h>
Index: carrier/Makefile.am
===================================================================
--- carrier/Makefile.am.orig
+++ carrier/Makefile.am
@@ -108,6 +108,7 @@ carrier_SOURCES = \
 	gtkprivacy.c \
 	gtkrequest.c \
 	gtkroomlist.c \
+	gtkdisco.c \
 	gtksavedstatuses.c \
 	gtkscrollbook.c \
 	gtksession.c \
@@ -161,6 +162,7 @@ carrier_headers = \
 	gtkpounce.h \
 	gtkrequest.h \
 	gtkroomlist.h \
+	gtkdisco.h \
 	gtksavedstatuses.h \
 	gtkscrollbook.h \
 	gtksession.h \
Index: carrier/gtkblist.c
===================================================================
--- carrier/gtkblist.c.orig
+++ carrier/gtkblist.c
@@ -55,6 +55,7 @@
 #include "gtkprefs.h"
 #include "gtkprivacy.h"
 #include "gtkroomlist.h"
+#include "gtkdisco.h"
 #include "gtkstatusbox.h"
 #include "gtkscrollbook.h"
 #include "gtksmiley.h"
@@ -3291,6 +3292,7 @@ static GtkItemFactoryEntry blist_menu[] 
 	{ N_("/Tools/Smile_y"), "<CTL>Y", pidgin_smiley_manager_show, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_SMILEY },
 	{ "/Tools/sep2", NULL, NULL, 0, "<Separator>", NULL },
 	{ N_("/Tools/_File Transfers"), "<CTL>T", pidgin_xfer_dialog_show, 0, "<StockItem>", PIDGIN_STOCK_TOOLBAR_TRANSFER },
+	{ N_("/Tools/Service _Discovery"), NULL, pidgin_disco_dialog_show, 0, "<Item>", NULL },
 	{ N_("/Tools/R_oom List"), NULL, pidgin_roomlist_dialog_show, 0, "<Item>", NULL },
 	{ N_("/Tools/System _Log"), NULL, gtk_blist_show_systemlog_cb, 3, "<Item>", NULL },
 	{ "/Tools/sep3", NULL, NULL, 0, "<Separator>", NULL },
@@ -4160,6 +4162,9 @@ update_menu_bar(PidginBuddyList *gtkblis
 
 	widget = gtk_item_factory_get_widget(gtkblist->ift, N_("/Tools/Room List"));
 	gtk_widget_set_sensitive(widget, pidgin_roomlist_is_showable());
+
+	widget = gtk_item_factory_get_widget(gtkblist->ift, N_("/Tools/Service Discovery"));
+	gtk_widget_set_sensitive(widget, pidgin_disco_is_showable());
 }
 
 static void
Index: carrier/gtkmain.c
===================================================================
--- carrier/gtkmain.c.orig
+++ carrier/gtkmain.c
@@ -60,6 +60,7 @@
 #include "gtkprivacy.h"
 #include "gtkrequest.h"
 #include "gtkroomlist.h"
+#include "gtkdisco.h"
 #include "gtksavedstatuses.h"
 #include "gtksession.h"
 #include "gtksmiley.h"
@@ -307,6 +308,7 @@ pidgin_ui_init(void)
 	pidgin_privacy_init();
 	pidgin_xfers_init();
 	pidgin_roomlist_init();
+	pidgin_disco_init();
 	pidgin_log_init();
 	pidgin_docklet_init();
 	pidgin_smileys_init();
